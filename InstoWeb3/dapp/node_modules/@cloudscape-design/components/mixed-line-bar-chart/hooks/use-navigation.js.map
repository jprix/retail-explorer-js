{"version":3,"file":"use-navigation.js","sourceRoot":"","sources":["../../../../src/mixed-line-bar-chart/hooks/use-navigation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps, VerticalMarkerX } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n  clearHighlightedSeries(): void;\n  verticalMarkerX: VerticalMarkerX<T> | null;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n  highlightX,\n  verticalMarkerX,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n  const [xIndex, setXIndex] = useState(0);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(({ series }) => series.type === 'bar'), [visibleSeries]);\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineFocus = () => {\n    if (verticalMarkerX === null) {\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(0);\n      } else {\n        moveBetweenSeries(0);\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({ scaledX: point.x, datum: point.datum });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n\n  const moveBetweenSeries = useCallback(\n    (direction: number) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      // If index === -1, show all data points from all series at the given X instead of one single series\n      const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== null) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = firstPossibleIndex;\n        } else if (nextSeriesIndex < firstPossibleIndex) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n      if (nextSeriesIndex === -1) {\n        highlightSeries(null);\n        highlightPoint(null);\n        return;\n      }\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(targetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n        const closestNextSeriesPoint = nextScaledSeries.reduce(\n          (prev, curr) => (Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev),\n          { x: -Infinity, y: -Infinity }\n        );\n        highlightPoint({ ...closestNextSeriesPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (isYThreshold(nextSeries)) {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(targetX);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      } else if (isXThreshold(nextSeries)) {\n        highlightPoint({\n          x: xScale.d3Scale(nextSeries.x as any) ?? NaN,\n          y: yScale.d3Scale.range()[0],\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: { x: nextSeries.x, y: NaN },\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      containsMultipleSeries,\n      highlightSeries,\n      highlightPoint,\n      series,\n      targetX,\n      scaledSeries,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n\n      if (series.type === 'line' || isYThreshold(series)) {\n        const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n        const previousPoint = highlightedPoint || targetScaledSeries[0];\n        const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n        const nextPoint = targetScaledSeries[nextPointIndex];\n\n        setTargetX(nextPoint.datum?.x || null);\n        setXIndex(nextPointIndex);\n        highlightPoint(nextPoint);\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      scaledSeries,\n      highlightedPoint,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n    ]\n  );\n\n  const moveToLineGroupIndex = useCallback(\n    (index: number) => {\n      const point = allUniqueX[index];\n      setXIndex(index);\n      setTargetX(point.datum?.x || null);\n      highlightX({ scaledX: point?.scaledX ?? null, label: point.datum?.x ?? null });\n    },\n    [allUniqueX, highlightX]\n  );\n\n  const moveWithinXAxis = useCallback(\n    (direction: number) => {\n      if (highlightedSeries || isGroupNavigation) {\n        moveWithinSeries(direction);\n      } else {\n        const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n        moveToLineGroupIndex(nextPointGroupIndex);\n      }\n    },\n    [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown, xIndex };\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n"]}